use std::collections::HashMap;
use std::fs;
use std::io;
use std::path::Path;
use std::process::Command;

use crate::backend::project::{Project, Environment, ProjectInfo, Tilt, TiltMode};

/// Create a new project workspace
pub fn create_project(
    name: &str,
    workspace_path: &str,
    services_path: Option<&str>,
) -> io::Result<Project> {
    let services_path = services_path.unwrap_or("repos");
    let project_path = std::path::PathBuf::from(workspace_path).join(name);
    let dirs = [services_path, "tilt", ".tooling"];

    for dir in dirs.iter() {
        fs::create_dir_all(project_path.join(dir))?;
    }

    let mut environments = HashMap::new();
    environments.insert(
        "dev".to_string(),
        Environment {
            shared_env: HashMap::new(),
            services: Vec::new(),
        },
    );
    environments.insert(
        "staging".to_string(),
        Environment {
            shared_env: HashMap::new(),
            services: Vec::new(),
        },
    );
    environments.insert(
        "prod".to_string(),
        Environment {
            shared_env: HashMap::new(),
            services: Vec::new(),
        },
    );

    let project = Project {
        project: ProjectInfo {
            name: name.to_string(),
            workspace_path: project_path.to_string_lossy().to_string(),
            tilt: Tilt {
                mode: TiltMode::Root,
            },
            services_path: Some(services_path.to_string()),
        },
        environments,
    };

    Ok(project)
}

/// Open a repository in the userâ€™s editor (default VSCode)
pub fn open_in_editor(
    workspace: &Path,
    repo_name: &str,
    editor: Option<&str>,
    services_path: Option<&str>,
) -> io::Result<()> {
    let editor = editor.unwrap_or("code");
    let services_path = services_path.unwrap_or("repos");
    let repo_path = workspace.join(services_path).join(repo_name);

    if !repo_path.exists() {
        return Err(io::Error::new(
            io::ErrorKind::NotFound,
            format!("Repo {} does not exist at {:?}", repo_name, repo_path),
        ));
    }

    let status = Command::new(editor)
        .arg(repo_path)
        .status();

    match status {
        Ok(s) if s.success() => Ok(()),
        Ok(s) => {
            eprintln!("Failed to open editor: exited with status {}", s);
            Ok(())
        }
        Err(e) => {
            eprintln!("Failed to open editor: {}", e);
            Ok(())
        }
    }
}